var tipuesearch = {"pages":[{"title":" WignerD ","text":"WignerD Provides procedures to calculate the Wigner matrices and in their real forms.\nThe matrix can be obtained via its analytic expression (2) or via matrix diagonalization 1 (#1) . The matrix diagonalization method is used by default , but the analytic method can be forced with an optional parameter in all interfaces.\nThe factorial terms in (2) can easily overflow double precision for approximately the following values of j: # bits critical 32 17 64 86 128 878 This problem is avoided when using the matrix diagonalization method of Feng et al. 1 (#1) .\nFor larger , the matrix diagonalization method quickly becomes faster than the analytic version. Dependencies LAPACK's ZHBEV routine, which is made available in the Fortran standard library . [ optional ] The Fortran Package Manager (fpm) for easy building. Building with fpm In the package directory, run $ fpm build --profile release The archive file libWignerD.a and several .mod files will be placed in the generated build subdirectory.\nIf you'd rather use your local version of LAPACK, use the flag $ fpm build --profile release --flag = \"-DUSE_EXTERNAL_LAPACK\" Building without fpm Assuming you have a local installation of LAPACK and that your linker program knows where to find it, just run the provided compile script: $ ./compile The default compiler is gfortran .\nThe archive file libwignerd.a and several .mod files will be placed in the generated build/lib and build/mod subdirectories.\nThese will be needed for reference by another program. Testing A few tests are included for explicit values of the for several values of the angle .\nJust run $ fpm test Usage To use this project within your fpm project, add the following to your fpm.toml file: [dependencies] wignerd = { git = \"https://github.com/banana-bred/WignerD\" } Otherwise, you will just need the generated archive and mod files mentioned above.\nDon't forget to tell your compiler where they are. Available routines/interfaces/procedures The module wignerd contains the following public interfaces, which can be accessed via the use statement : interface description wigner_d(...) This is an interface wrapper for wigner_little_d and wigner_big_d , depending on the number of arguments that you provide. wigner_little_d(...) Returns via the analytic expression or matrix diagonalization. See docs for details. wigner_big_D(...) Returns via the analytic expression or matrix diagonalization. See docs for details. More info on input/output types throughout the docs. Example Calculate and : program D use , intrinsic :: iso_fortran_env , only : wp => real64 use wignerd , only : wigner_d , wigner_big_D , wigner_little_d use wignerd__constants , only : one , two , pi real ( wp ), allocatable :: little_d1 (:,:) real ( wp ), allocatable :: little_d2 (:,:) real ( wp ), allocatable :: big_D1 (:,:) real ( wp ), allocatable :: big_D2 (:,:) real ( wp ) :: j , euler_alpha , euler_beta , euler_gamma j = one / two euler_alpha = pi / 6 euler_beta = pi / 2 euler_gamma = pi little_d1 = wigner_d ( j , euler_beta ) ! -- calculate d &#94; j ( β ) little_d2 = wigner_little_d ( j , euler_beta ) ! -- calculate d &#94; j ( β ) big_D1 = wigner_d ( j , euler_alpha , euler_beta , euler_gamma ) ! -- calculate D &#94; j ( α , β , γ ) big_D2 = wigner_big_D ( j , euler_alpha , euler_beta , euler_gamma ) ! -- calculate D &#94; j ( α , β , γ ) end program D In the above, arrays big_D1 and big_D2 will hold the same information because they end up calling the same routines (the same goes for little_d1 and little_d2 ).\nThe above calls default to the diagonalization method to obtain and .\nWe can force the use of the analytic expression via the optional input parameter use_analytic : little_d1 = wigner_little_d(j, euler_beta) ! <--------------------------------- matrix diagonalization\nlittle_d2 = wigner_little_d(j, euler_beta, use_analytic = .true.) ! <---------- analytic\nbig_D1    = wigner_big_D(j, euler_alpha, euler_beta, euler_beta) ! <----------- matrix diagonalization\nbig_D2    = wigner_big_D(j,  euler_alpha, euler_beta, euler_beta, .true.) ! <-- analytic Happy rotating ! Reference(s) [1] X. M. Feng, P. Wang, W. Yang, and G. R. Jin, High-precision evaluation of Wigner's matrix by exact diagonalization ,\nPhys. Rev. E. 2015, 92, 043307,\nURL: https://doi.org/10.1103/PhysRevE.92.043307","tags":"home","loc":"index.html"},{"title":"wigner_d – WignerD","text":"public interface wigner_d Interface to access the routines to calculate the matrix D(α,β,γ) or d(β)\nbased on the number of arguments Module Procedures private module function wigner_big_D_jint(j, euler_alpha, euler_beta, euler_gamma, use_analytic) result(D) Return the wigner D-matrix for integer j Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_alpha The Euler angle α real(kind=rp), intent(in) :: euler_beta The Euler angle β real(kind=rp), intent(in) :: euler_gamma The Euler angle γ logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value complex(kind=rp), allocatable, (:,:) The Wigner D-matrix private module function wigner_big_D_jreal(j, euler_alpha, euler_beta, euler_gamma, use_analytic) result(D) Return the wigner D-matrix for real j Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_alpha The Euler angle α real(kind=rp), intent(in) :: euler_beta The Euler angle β real(kind=rp), intent(in) :: euler_gamma The Euler angle γ logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value complex(kind=rp), allocatable, (:,:) The Wigner D-matrix private module function wigner_little_d_jint(j, euler_beta, use_analytic) result(d) Return the Wigner d-matrix for integer j Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_beta The euler angle β logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value real(kind=rp), allocatable, (:,:) The matrix private module function wigner_little_d_jreal(j, euler_beta, use_analytic) result(d) Return the Wigner d-matrix for real j Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_beta The euler angle β logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value real(kind=rp), allocatable, (:,:) The matrix","tags":"","loc":"interface/wigner_d.html"},{"title":"wigner_big_D – WignerD","text":"public interface wigner_big_D Interface to access the routines to calculate D(α,β,γ) via matrix diagonalization\nor the analytic expression Module Procedures private module function wigner_big_D_jint(j, euler_alpha, euler_beta, euler_gamma, use_analytic) result(D) Return the wigner D-matrix for integer j Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_alpha The Euler angle α real(kind=rp), intent(in) :: euler_beta The Euler angle β real(kind=rp), intent(in) :: euler_gamma The Euler angle γ logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value complex(kind=rp), allocatable, (:,:) The Wigner D-matrix private module function wigner_big_D_jreal(j, euler_alpha, euler_beta, euler_gamma, use_analytic) result(D) Return the wigner D-matrix for real j Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_alpha The Euler angle α real(kind=rp), intent(in) :: euler_beta The Euler angle β real(kind=rp), intent(in) :: euler_gamma The Euler angle γ logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value complex(kind=rp), allocatable, (:,:) The Wigner D-matrix","tags":"","loc":"interface/wigner_big_d.html"},{"title":"wigner_little_d – WignerD","text":"public interface wigner_little_d Interface to access the routines to calculate d(β) via matrix diagonalization\nor the analytic expression Module Procedures private module function wigner_little_d_jint(j, euler_beta, use_analytic) result(d) Return the Wigner d-matrix for integer j Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_beta The euler angle β logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value real(kind=rp), allocatable, (:,:) The matrix private module function wigner_little_d_jreal(j, euler_beta, use_analytic) result(d) Return the Wigner d-matrix for real j Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_beta The euler angle β logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value real(kind=rp), allocatable, (:,:) The matrix","tags":"","loc":"interface/wigner_little_d.html"},{"title":"int2char – WignerD","text":"public recursive function int2char(i) result(output) Convert the integer i to a character (array) \"i\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable The integer \"i\" as a character array, e.g.\nint2char(2) \"2\"\nint2char(16) \"16\"","tags":"","loc":"proc/int2char.html"},{"title":"ndigits – WignerD","text":"public pure elemental function ndigits(n) result(num) Uses wignerd__constants Returns number of characters an integer will occupy Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer The number of characters it takes to represent a number, e.g.\nndigits(7) 1\nndigits(-7) 2\nndigits(38) 2\nndigits(3877) 7","tags":"","loc":"proc/ndigits.html"},{"title":"die – WignerD","text":"public interface die Stop program execution with one or two messages Module Procedures private  subroutine die_1(message) Stop program execution with a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private  subroutine die_2(message1, message2) Stop program execution with two messages Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message1 character(len=*), intent(in) :: message2","tags":"","loc":"interface/die.html"},{"title":"zhbev – WignerD","text":"public interface zhbev This interface exists in case the user wants to use their own\nimplementation of the LAPACK routine ZHBEV and not the one\nfound in the standard library. Subroutines private  subroutine zhbev(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1) :: jobz character(len=1) :: uplo integer :: n integer :: kd complex(kind=real64) :: ab (ldab,*) integer :: ldab real(kind=real64) :: w (*) complex(kind=real64) :: z (ldz,*) integer :: ldz complex(kind=real64) :: work (*) real(kind=real64) :: rwork (*) integer :: info","tags":"","loc":"interface/zhbev.html"},{"title":"delta – WignerD","text":"public pure elemental function delta(m, n) result(res) Uses wignerd__types wignerd__constants Return the Kronecker delta function Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value real(kind=rp)","tags":"","loc":"proc/delta.html"},{"title":"factorial – WignerD","text":"public interface factorial Returns for integer or double precision real Module Procedures private pure elemental function factorial_int(n) result(res) Returns for integer Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rp) private pure elemental function factorial_real(n) result(res) Returns for double precision real Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: n Return Value real(kind=rp)","tags":"","loc":"interface/factorial.html"},{"title":"wignerd – WignerD","text":"Module for computing the Wigner D-matrix and d-matrix (big D and little d; Fortran is case insensitive).\nThe d-matrix can be calculated via the analytic expression, but this can overflow for large j due to\nthe ratios of large factoials. The d-matrix can instead be calculated via sparse banded matrix\ndiagonalization. See DOI: 10.1103PhysRevE.92.043307 for more details. Interfaces public        interface wigner_d Interface to access the routines to calculate the matrix D(α,β,γ) or d(β)\nbased on the number of arguments private module function wigner_big_D_jint(j, euler_alpha, euler_beta, euler_gamma, use_analytic) result(D) Return the wigner D-matrix for integer j Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_alpha The Euler angle α real(kind=rp), intent(in) :: euler_beta The Euler angle β real(kind=rp), intent(in) :: euler_gamma The Euler angle γ logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value complex(kind=rp), allocatable, (:,:) The Wigner D-matrix private module function wigner_big_D_jreal(j, euler_alpha, euler_beta, euler_gamma, use_analytic) result(D) Return the wigner D-matrix for real j Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_alpha The Euler angle α real(kind=rp), intent(in) :: euler_beta The Euler angle β real(kind=rp), intent(in) :: euler_gamma The Euler angle γ logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value complex(kind=rp), allocatable, (:,:) The Wigner D-matrix private module function wigner_little_d_jint(j, euler_beta, use_analytic) result(d) Return the Wigner d-matrix for integer j Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_beta The euler angle β logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value real(kind=rp), allocatable, (:,:) The matrix private module function wigner_little_d_jreal(j, euler_beta, use_analytic) result(d) Return the Wigner d-matrix for real j Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_beta The euler angle β logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value real(kind=rp), allocatable, (:,:) The matrix public        interface wigner_big_D Interface to access the routines to calculate D(α,β,γ) via matrix diagonalization\nor the analytic expression private module function wigner_big_D_jint(j, euler_alpha, euler_beta, euler_gamma, use_analytic) result(D) Return the wigner D-matrix for integer j Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_alpha The Euler angle α real(kind=rp), intent(in) :: euler_beta The Euler angle β real(kind=rp), intent(in) :: euler_gamma The Euler angle γ logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value complex(kind=rp), allocatable, (:,:) The Wigner D-matrix private module function wigner_big_D_jreal(j, euler_alpha, euler_beta, euler_gamma, use_analytic) result(D) Return the wigner D-matrix for real j Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_alpha The Euler angle α real(kind=rp), intent(in) :: euler_beta The Euler angle β real(kind=rp), intent(in) :: euler_gamma The Euler angle γ logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value complex(kind=rp), allocatable, (:,:) The Wigner D-matrix public        interface wigner_little_d Interface to access the routines to calculate d(β) via matrix diagonalization\nor the analytic expression private module function wigner_little_d_jint(j, euler_beta, use_analytic) result(d) Return the Wigner d-matrix for integer j Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_beta The euler angle β logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value real(kind=rp), allocatable, (:,:) The matrix private module function wigner_little_d_jreal(j, euler_beta, use_analytic) result(d) Return the Wigner d-matrix for real j Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: j The angular momentum real(kind=rp), intent(in) :: euler_beta The euler angle β logical, intent(in), optional :: use_analytic Force the use of the analytic expression to obtain ? Return Value real(kind=rp), allocatable, (:,:) The matrix","tags":"","loc":"module/wignerd.html"},{"title":"wignerd__characters – WignerD","text":"Contains procedures related to characters and character arrays,\nsuch as converting integers to characters Uses wignerd__types Functions public recursive function int2char (i) result(output) Convert the integer i to a character (array) \"i\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable The integer \"i\" as a character array, e.g.\nint2char(2) \"2\"\nint2char(16) \"16\" public pure elemental function ndigits (n) result(num) Returns number of characters an integer will occupy Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer The number of characters it takes to represent a number, e.g.\nndigits(7) 1\nndigits(-7) 2\nndigits(38) 2\nndigits(3877) 7","tags":"","loc":"module/wignerd__characters.html"},{"title":"wignerd__types – WignerD","text":"Module containing defining the precision for real and complex types Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: rp = real64 The precision for real and complex types. real(kind=rp), public, parameter :: rp_huge = huge(1.0_rp) The largest representable real number with precision real(rp)","tags":"","loc":"module/wignerd__types.html"},{"title":"wignerd__system – WignerD","text":"Contains the definitions of stderr and procedures to stop the execution of the program while\nprinting error messages. Uses wignerd__types iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: stderr = error_unit The file unit associated with standard error Interfaces public        interface die Stop program execution with one or two messages private  subroutine die_1(message) Stop program execution with a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private  subroutine die_2(message1, message2) Stop program execution with two messages Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message1 character(len=*), intent(in) :: message2","tags":"","loc":"module/wignerd__system.html"},{"title":"wignerd__constants – WignerD","text":"Contains defined constants Uses wignerd__types Variables Type Visibility Attributes Name Initial real(kind=rp), public, parameter :: ahalf = 0.5_rp real(kind=rp), public, parameter :: zero = 0._rp real(kind=rp), public, parameter :: one = 1._rp real(kind=rp), public, parameter :: two = 2._rp real(kind=rp), public, parameter :: three = 3._rp real(kind=rp), public, parameter :: four = 4._rp real(kind=rp), public, parameter :: pi = atan(1._rp)*4._rp π complex(kind=rp), public, parameter :: im = (zero, one) the square root of -1","tags":"","loc":"module/wignerd__constants.html"},{"title":"wignerd__lapack_interface – WignerD","text":"Select at build time which lapack implementation to use Interfaces public        interface zhbev This interface exists in case the user wants to use their own\nimplementation of the LAPACK routine ZHBEV and not the one\nfound in the standard library. private  subroutine zhbev(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1) :: jobz character(len=1) :: uplo integer :: n integer :: kd complex(kind=real64) :: ab (ldab,*) integer :: ldab real(kind=real64) :: w (*) complex(kind=real64) :: z (ldz,*) integer :: ldz complex(kind=real64) :: work (*) real(kind=real64) :: rwork (*) integer :: info","tags":"","loc":"module/wignerd__lapack_interface.html"},{"title":"wignerd__functions – WignerD","text":"Contains various functions used in the code Interfaces public        interface factorial Returns for integer or double precision real private pure elemental function factorial_int(n) result(res) Returns for integer Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rp) private pure elemental function factorial_real(n) result(res) Returns for double precision real Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: n Return Value real(kind=rp) Functions public pure elemental function delta (m, n) result(res) Return the Kronecker delta function Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value real(kind=rp)","tags":"","loc":"module/wignerd__functions.html"},{"title":"wignerd.f – WignerD","text":"Source Code ! ================================================================================================================================ ! module wignerd !! Module for computing the Wigner D-matrix and d-matrix (big D and little d; Fortran is case insensitive). !! The d-matrix can be calculated via the analytic expression, but this can overflow for large j due to !! the ratios of large factoials. The d-matrix can instead be calculated via sparse banded matrix !! diagonalization. See DOI: 10.1103PhysRevE.92.043307 for more details. implicit none private public :: wigner_d public :: wigner_big_D public :: wigner_little_d ! ------------------------------------------------------------------------------------------------------------------------------ ! interface wigner_d !! Interface to access the routines to calculate the matrix D(α,β,γ) or d(β) !! based on the number of arguments module procedure :: wigner_big_D_jint module procedure :: wigner_big_D_jreal module procedure :: wigner_little_d_jint module procedure :: wigner_little_d_jreal end interface wigner_d ! ------------------------------------------------------------------------------------------------------------------------------ ! interface wigner_big_D !! Interface to access the routines to calculate D(α,β,γ) via matrix diagonalization !! or the analytic expression module procedure :: wigner_big_D_jint module procedure :: wigner_big_D_jreal end interface wigner_big_D ! ------------------------------------------------------------------------------------------------------------------------------ ! interface wigner_little_d !! Interface to access the routines to calculate d(β) via matrix diagonalization !! or the analytic expression module procedure :: wigner_little_d_jint module procedure :: wigner_little_d_jreal end interface wigner_little_d ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! module function wigner_big_D_jint ( j , euler_alpha , euler_beta , euler_gamma , use_analytic ) result ( D ) !! Return the wigner D-matrix D&#94;j_{m',m}(\\alpha, \\beta, \\gamma) for integer j use wignerd__types , only : rp use wignerd__constants , only : im implicit none integer , intent ( in ) :: j !! The angular momentum j real ( rp ), intent ( in ) :: euler_alpha !! The Euler angle α real ( rp ), intent ( in ) :: euler_beta !! The Euler angle β real ( rp ), intent ( in ) :: euler_gamma !! The Euler angle γ logical , intent ( in ), optional :: use_analytic !! Force the use of the analytic expression to obtain d&#94;j(\\beta) ? complex ( rp ), allocatable :: D (:,:) !! The Wigner D-matrix D&#94;j(\\alpha,\\beta,\\gamma) logical :: use_analytic_local use_analytic_local = . false . ; if ( present ( use_analytic )) use_analytic_local = use_analytic D = wigner_big_D_jreal ( real ( j , kind = rp ), euler_alpha , euler_beta , euler_gamma , use_analytic_local ) end function wigner_big_D_jint ! ------------------------------------------------------------------------------------------------------------------------------ ! module function wigner_big_D_jreal ( j , euler_alpha , euler_beta , euler_gamma , use_analytic ) result ( D ) !! Return the wigner D-matrix D&#94;j_{m',m}(\\alpha, \\beta, \\gamma) for real j use wignerd__types , only : rp use wignerd__constants , only : one , im implicit none real ( rp ), intent ( in ) :: j !! The angular momentum j real ( rp ), intent ( in ) :: euler_alpha !! The Euler angle α real ( rp ), intent ( in ) :: euler_beta !! The Euler angle β real ( rp ), intent ( in ) :: euler_gamma !! The Euler angle γ logical , intent ( in ), optional :: use_analytic !! Force the use of the analytic expression to obtain d&#94;j(\\beta) ? complex ( rp ), allocatable :: D (:,:) !! The Wigner D-matrix D&#94;j(\\alpha,\\beta,\\gamma) logical :: use_analytic_local integer :: n integer :: i , k real ( rp ) :: m , mp real ( rp ), allocatable :: little_d (:,:) n = nint ( 2 * j ) + 1 use_analytic_local = . false . ; if ( present ( use_analytic )) use_analytic_local = use_analytic ! -- allocate D D = wigner_little_d_jreal ( j , euler_beta , use_analytic ) little_d = D do concurrent ( i = 1 : n , k = 1 : n ) mp = - j + i - 1 m = - j + k - 1 D ( i , k ) = exp ( - im * mp * euler_alpha ) * little_d ( i , k ) * exp ( - im * m * euler_gamma ) enddo end function wigner_big_D_jreal ! ------------------------------------------------------------------------------------------------------------------------------ ! module function wigner_little_d_jint ( j , euler_beta , use_analytic ) result ( d ) !! Return the Wigner d-matrix d&#94;j_{m'm}(\\beta) for integer j use wignerd__types , only : rp implicit none integer , intent ( in ) :: j !! The angular momentum j real ( rp ), intent ( in ) :: euler_beta !! The euler angle β logical , intent ( in ), optional :: use_analytic !! Force the use of the analytic expression to obtain d&#94;j(\\beta) ? real ( rp ), allocatable :: d (:,:) !! The matrix d&#94;j(\\beta) logical :: use_analytic_Local use_analytic_local = . false . ; if ( present ( use_analytic )) use_analytic_local = use_analytic d = wigner_little_d_jreal ( real ( j , kind = rp ), euler_beta , use_analytic_local ) end function wigner_little_d_jint ! ------------------------------------------------------------------------------------------------------------------------------ ! module function wigner_little_d_jreal ( j , euler_beta , use_analytic ) result ( d ) !! Return the Wigner d-matrix d&#94;j_{m'm}(\\beta) for real j use wignerd__types , only : rp use wignerd__constants , only : one implicit none real ( rp ), intent ( in ) :: j !! The angular momentum j real ( rp ), intent ( in ) :: euler_beta !! The euler angle β logical , intent ( in ), optional :: use_analytic !! Force the use of the analytic expression to obtain d&#94;j(\\beta) ? real ( rp ), allocatable :: d (:,:) !! The matrix d&#94;j(\\beta) logical :: use_analytic_local use_analytic_local = . false . ; if ( present ( use_analytic )) use_analytic_local = use_analytic if ( use_analytic_local . eqv . . true .) then ! -- use the analytic expression d = wigner_little_d_analytic ( j , euler_beta ) return endif ! -- use the matrix diagonalization d = wigner_little_d_diag ( j , euler_beta ) end function wigner_little_d_jreal ! ------------------------------------------------------------------------------------------------------------------------------ ! module function wigner_little_d_analytic ( j , euler_beta ) result ( little_d ) !! Return the Wigner d-matrix d&#94;j_{m',m}(\\beta) via the analytic expression for real j use wignerd__types , only : rp use wignerd__system , only : die use wignerd__constants , only : zero , two use wignerd__functions , only : fact => factorial implicit none real ( rp ), intent ( in ) :: j !! The angular momentum j real ( rp ), intent ( in ) :: euler_beta !! The euler angle β real ( rp ), allocatable :: little_d (:,:) !! The matrix d&#94;j(\\beta) integer :: i , k integer :: n integer :: two_s real ( rp ) :: d real ( rp ) :: m , mp real ( rp ) :: s real ( rp ) :: smin , smax real ( rp ) :: numer , denom if ( nint ( 2 * j ) . lt . 0 ) call die ( \"The angular momentum j cannot be negative\" ) n = nint ( 2 * j ) + 1 allocate ( little_d ( n , n )) do concurrent ( i = 1 : n , k = 1 : n ) mp = - j + i - 1 m = - j + k - 1 smin = max ( zero , m - mp ) smax = min ( j + m , j - mp ) d = 0 do two_s = nint ( 2 * smin ), nint ( 2 * smax ), 2 s = two_s / two numer = ( - 1 ) ** ( mp - m + s ) & * cos ( euler_beta / 2 ) ** ( 2 * j + m - mp - 2 * s ) & * sin ( euler_beta / 2 ) ** ( mp - m + 2 * s ) denom = fact ( j + m - s ) * fact ( s ) * fact ( mp - m + s ) * fact ( j - mp - s ) d = d + numer / denom enddo little_d ( i , k ) = d * sqrt ( fact ( j + mp ) * fact ( j - mp ) * fact ( j + m ) * fact ( j - m ) ) enddo end function wigner_little_d_analytic ! ------------------------------------------------------------------------------------------------------------------------------ ! module function wigner_little_d_diag ( j , euler_beta ) result ( little_d ) !! Return the Wigner d-matrix d&#94;j_{m',m}(\\beta) via matrix diagonalization for real j !! see DOI: 10.1103PhysRevE.92.043307 for more details use wignerd__types , only : rp use wignerd__system , only : die use wignerd__constants , only : zero use wignerd__characters , only : int2char implicit none real ( rp ), intent ( in ) :: j !! The angular momentum j real ( rp ), intent ( in ) :: euler_beta !! The Euler angle β complex ( rp ), allocatable :: Jy (:,:) !! The operator J_y in matrix form real ( rp ), allocatable :: little_d (:,:) !! The matrix d&#94;j(\\beta) integer :: n integer :: row , col real ( rp ) :: mrow , mcol real ( rp ), allocatable :: eigvals (:) complex ( rp ), allocatable :: eigvecs (:,:) if ( nint ( 2 * j ) . lt . 0 ) call die ( \"The angular momentum j cannot be negative\" ) n = nint ( 2 * j ) + 1 allocate ( Jy ( n , n )) ; Jy = zero ! -- iterate over the rows and columns to populate Jy(:,:). !    The projections m of j for the rows and columns go from -j to j in steps of 1 do concurrent ( row = 1 : n , col = 1 : n ) mrow = - j + ( row - 1 ) mcol = - j + ( col - 1 ) Jy ( row , col ) = Jy_element ( j , mrow , mcol ) enddo ! -- diagonalize the Jy matrix diag : block use wignerd__characters , only : int2char #ifdef USE_EXTERNAL_LAPACK use wignerd__lapack_interface , only : zhbev #else use stdlib_linalg_lapack , only : zhbev => stdlib_zhbev #endif integer :: i , k integer :: kd integer :: ldab , ldz integer :: info integer :: nrwork real ( rp ), allocatable :: rwork (:) complex ( rp ), allocatable :: work (:) complex ( rp ), allocatable :: AB (:,:) character :: jobz , uplo jobz = \"V\" ! -- get eigenvectors too uplo = \"U\" ! -- store upper triangle of Jy kd = 1 ! -- one superdiagonal ldab = kd + 1 ldz = n nrwork = max ( 1 , 3 * n - 2 ) allocate ( eigvals ( n )) allocate ( work ( n )) allocate ( rwork ( nrwork )) allocate ( eigvecs ( ldz , n )) allocate ( AB ( ldab , n )) ! -- build the band matrix AB AB = zero do k = 1 , n do i = max ( 1 , k - kd ), k AB ( kd + 1 + i - k , k ) = Jy ( i , k ) enddo enddo call zhbev ( jobz , uplo , n , kd , AB , ldab , eigvals , eigvecs , ldz , work , rwork , info ) if ( info . ne . 0 ) call die ( \"Procedure ZHBEV returned with INFO = \" // int2char ( info )) end block diag build_little_d : block use wignerd__constants , only : im integer :: i , k integer :: imu real ( rp ) :: cos_term ( n ), sin_term ( n ) allocate ( little_d ( n , n )) ! -- fill the wigner d-matrix with its elements do concurrent ( i = 1 : n , k = 1 : n ) ! -- the inner product <i|\\mu>y just picks out the element i of the vector |\\mu>_y because !    the basis Jz is just the unit vectors. The product e&#94;{-i\\mu\\beta} \\left<i|\\mu\\right>_y{}_y\\left<\\mu|k\\right> is purely real, so !    so we only compute the real part associate ( mu => eigvals ) cos_term = cos ( mu (:) * euler_beta ) * ( eigvecs ( i , :) % re * eigvecs ( k , :) % re + eigvecs ( i , :) % im * eigvecs ( k , :) % im ) sin_term = sin ( mu (:) * euler_beta ) * ( eigvecs ( i , :) % im * eigvecs ( k , :) % re - eigvecs ( i , :) % re * eigvecs ( k , :) % im ) little_d ( i , k ) = sum ( cos_term + sin_term ) end associate enddo end block build_little_d ! ------------------------------------------------------------------------------------------------------------------------------ ! contains ! ------------------------------------------------------------------------------------------------------------------------------ ! ! -- ! pure elemental function Jy_element ( j , m , n ) result ( output ) !! Returns the matrix element <jm'|J_y|jm> from the above reference: !!   <jm | J_y | jn> = [ X_{-n} δ_{m,n+1} - X_{n}δ_{m,n-1} ] / (2i) !! where X_m = sqrt( (j+m)(j-m+1) ) use wignerd__types , only : rp use wignerd__functions , only : delta use wignerd__constants , only : im , zero implicit none real ( rp ), intent ( in ) :: j !! The angular momentum j real ( rp ), intent ( in ) :: m , n !! The projections of j integer :: double_m , double_n !! for passing integer arguments to delta() in case of half integer projections complex ( rp ) :: output double_m = nint ( 2 * m ) double_n = nint ( 2 * n ) output = ( X ( j , - n ) * delta ( double_m , double_n + 2 ) - X ( j , n ) * delta ( double_m , double_n - 2 ) ) / ( 2 * im ) end function Jy_element ! -- ! pure elemental function X ( j , m ) result ( output ) !! Returns the quantity X_m = sqrt( (j + m) (j - m + 1) ) implicit none real ( rp ), intent ( in ) :: j , m real ( rp ) :: arg real ( rp ) :: output output = sqrt ( ( j + m ) * ( j - m + 1 ) ) end function X end function wigner_little_d_diag ! ================================================================================================================================ ! end module wignerd ! ================================================================================================================================ !","tags":"","loc":"sourcefile/wignerd.f.html"},{"title":"wignerd__characters.f – WignerD","text":"Source Code ! ================================================================================================================================ ! module wignerd__characters !! Contains procedures related to characters and character arrays, !! such as converting integers to characters use wignerd__types , only : rp implicit none private ! -- procedures public :: ndigits public :: int2char ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! recursive function int2char ( i ) result ( output ) !! Convert the integer i to a character (array) \"i\" implicit none integer , intent ( in ) :: i character (:), allocatable :: output !! The integer \"i\" as a character array, e.g. !! int2char(2)  \\to \"2\" !! int2char(16) \\to \"16\" integer :: n n = ndigits ( i ) ! -- allocate characters so that they're wide enough to write to allocate ( character ( n ) :: output ) write ( output , '(I0)' ) i end function int2char ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function ndigits ( n ) result ( num ) !! Returns number of characters an integer will occupy use wignerd__constants , only : one implicit none integer , intent ( in ) :: n integer :: num !! The number of characters it takes to represent a number, e.g. !! ndigits(7)    to 1 !! ndigits(-7)   to 2 !! ndigits(38)   to 2 !! ndigits(3877) to 7 num = 1 if ( n . eq . 0 ) return num = floor ( log10 ( abs ( n ) * one )) + 1 ! -- account for minus sign if ( n . lt . 1 ) num = num + 1 end function ndigits ! ================================================================================================================================ ! end module wignerd__characters ! ================================================================================================================================ !","tags":"","loc":"sourcefile/wignerd__characters.f.html"},{"title":"wignerd__types.f – WignerD","text":"Source Code ! ================================================================================================================================ ! module wignerd__types !! Module containing defining the precision for real and complex types use , intrinsic :: iso_fortran_env , only : real64 implicit none private ! -- types integer , parameter , public :: rp = real64 !! The precision for real and complex types. real ( rp ), parameter , public :: rp_huge = huge ( 1.0_rp ) !! The largest representable real number with precision `real(rp)` ! ================================================================================================================================ ! end module wignerd__types ! ================================================================================================================================ !","tags":"","loc":"sourcefile/wignerd__types.f.html"},{"title":"wignerd__system.f – WignerD","text":"Source Code ! ================================================================================================================================ ! module wignerd__system !! Contains the definitions of stderr and procedures to stop the execution of the program while !! printing error messages. use wignerd__types , only : rp use , intrinsic :: iso_fortran_env , only : error_unit implicit none private public die integer , parameter , public :: stderr = error_unit !! The file unit associated with standard error interface die !! Stop program execution with one or two messages module procedure die_1 module procedure die_2 end interface die ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine die_1 ( message ) !! Stop program execution with a message implicit none character ( * ), intent ( in ), optional :: message write ( stderr , * ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , '(\"@@@@                                                           @@@@\")' ) write ( stderr , '(\"@@@@                          ERROR                            @@@@\")' ) write ( stderr , '(\"@@@@                                                           @@@@\")' ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , * ) if (. not . present ( message )) error stop write ( stderr , '(\"STOP\",X,\"::\",X,A)' ) message write ( stderr , * ) error stop end subroutine die_1 ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine die_2 ( message1 , message2 ) !! Stop program execution with two messages implicit none character ( * ), intent ( in ) :: message1 character ( * ), intent ( in ) :: message2 write ( stderr , * ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , '(\"@@@@                                                           @@@@\")' ) write ( stderr , '(\"@@@@                          ERROR                            @@@@\")' ) write ( stderr , '(\"@@@@                                                           @@@@\")' ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , * ) write ( stderr , '(\"STOP\",X,\"::\",X,A,/,A)' ) message1 , message2 write ( stderr , * ) error stop end subroutine die_2 ! ================================================================================================================================ ! end module wignerd__system ! ================================================================================================================================ !","tags":"","loc":"sourcefile/wignerd__system.f.html"},{"title":"wignerd__constants.f – WignerD","text":"Source Code ! ================================================================================================================================ ! module wignerd__constants !! Contains defined constants use wignerd__types , only : rp implicit none private ! -- numbers real ( rp ), parameter , public :: ahalf = 0.5_rp real ( rp ), parameter , public :: zero = 0._rp real ( rp ), parameter , public :: one = 1._rp real ( rp ), parameter , public :: two = 2._rp real ( rp ), parameter , public :: three = 3._rp real ( rp ), parameter , public :: four = 4._rp real ( rp ), parameter , public :: pi = atan ( 1._rp ) * 4._rp !! π complex ( rp ), parameter , public :: im = ( zero , one ) !! the square root of -1 ! ================================================================================================================================ ! end module wignerd__constants ! ================================================================================================================================ !","tags":"","loc":"sourcefile/wignerd__constants.f.html"},{"title":"wignerd__lapack_interface.f – WignerD","text":"Source Code ! ================================================================================================================================ ! module wignerd__lapack_interface !! Select at build time which lapack implementation to use implicit none private public :: zhbev interface zhbev !! This interface exists in case the user wants to use their own !! implementation of the LAPACK routine `ZHBEV` and not the one !! found in the standard library. subroutine zhbev ( jobz , uplo , n , kd , ab , ldab , w , z , ldz , work , rwork , info ) use , intrinsic :: iso_fortran_env , only : real64 character :: jobz character :: uplo integer :: n integer :: kd complex ( real64 ) :: ab ( ldab , * ) integer :: ldab real ( real64 ) :: w ( * ) complex ( real64 ) :: z ( ldz , * ) integer :: ldz complex ( real64 ) :: work ( * ) real ( real64 ) :: rwork ( * ) integer :: info end subroutine end interface zhbev ! ================================================================================================================================ ! end module wignerd__lapack_interface ! ================================================================================================================================ !","tags":"","loc":"sourcefile/wignerd__lapack_interface.f.html"},{"title":"wignerd__functions.f – WignerD","text":"Source Code ! ================================================================================================================================ ! module wignerd__functions !! Contains various functions used in the code implicit none private public delta public factorial interface factorial !! Returns n! for integer or double precision real n module procedure :: factorial_int module procedure :: factorial_real end interface factorial ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function delta ( m , n ) result ( res ) !! Return the Kronecker delta function δ_{m,n} use wignerd__types , only : rp use wignerd__constants , only : zero , one implicit none integer , intent ( in ) :: m , n real ( rp ) :: res res = zero ; if ( m . eq . n ) res = one end function delta ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function factorial_int ( n ) result ( res ) !! Returns n! for integer n use wignerd__types , only : rp implicit none integer , intent ( in ) :: n real ( rp ) :: res res = gamma ( real ( n + 1 , kind = rp )) end function factorial_int ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function factorial_real ( n ) result ( res ) !! Returns n! for double precision real n use wignerd__types , only : rp use wignerd__constants , only : one implicit none real ( rp ), intent ( in ) :: n real ( rp ) :: res res = gamma ( n + one ) end function factorial_real ! ================================================================================================================================ ! end module wignerd__functions ! ================================================================================================================================ !","tags":"","loc":"sourcefile/wignerd__functions.f.html"}]}